# Copyright DST Group. Licensed under the MIT license.
from datetime import datetime
from ipaddress import IPv4Address


# use msf module auxiliary/scanner/ssh/ssh_login
# set RHOSTS to target, maybe set VERBOSE to false, also can set RPORT but this is 22 by default
# set USERPASS_FILE (I set it to "/usr/share/metasploit_framework/data/wordlists/root_userpass.txt", having first added
# credentials "user user" to last line of file)
# Gives non-TTY session that needs to be interacted with first with "sessions -i 1" (may not be 1)
from time import strptime

from CybORG.Shared.Actions.MSFActionsFolder.MSFAction import lo, lo_subnet
from CybORG.Shared.Actions.MSFActionsFolder.RemoteCodeExecutionFolder.RemoteCodeExecution import RemoteCodeExecution
from CybORG.Shared.Enums import SessionType, ProcessType, OperatingSystemType
from CybORG.Shared.Observation import Observation
from CybORG.Simulator.State import State


class SSHLoginExploit(RemoteCodeExecution):
    def __init__(self, ip_address: IPv4Address, agent: str, session: int, port: int):
        # doesn't have a target_session??
        super().__init__(session=session, agent=agent)
        self.ip_address = ip_address
        self.port = port # ie process/service name

    def sim_execute(self, state: State):
        obs = Observation()
        obs.set_success(False)

        server_sessions = [ s for s in state.sessions[self.agent] if s.ident == self.session]
        if self.session not in [ s.ident for s in server_sessions if s.session_type == SessionType.MSF_SERVER and s.active]:
            # invalid server session
            obs.set_success(False)
            return obs

        # choose first server session
        session = server_sessions[0]
        from_host = session.host

        # check the target is routable 
        # we don't currently have a concept of network route table in the simulator
        # we determine this by the routes attribute in the sessions
        # if the ip address is contained within a subnet that is within the routes attribute of any valid target session
        # the target is accesible
        target_subnet = None
        ports = None
        if self.ip_address == lo:
            target_subnet = lo_subnet
            server_interface = [i for i in state.hosts[session.host].interfaces if i.ip_address == lo][0]
            ports = ["all"]
        else:
            for subnet in state.subnets.values():
                if self.ip_address in subnet.ip_addresses:
                    target_subnet = subnet
                    break

            server_session, server_interface = self.get_local_source_interface(local_session=session, remote_address=self.ip_address,
                                                                      state=state)

            if server_interface is None:
                #print("server_interface is None")
                return obs

            # replace with the updated check_routable
            # this checks it is network accessible
            ports = self.check_routable(from_subnets=[state.subnets[server_interface.subnet]], to_subnets=[target_subnet])
            #if not self.test_nacl(port=self.port, target_subnet=target_subnet,
            #                      originating_subnet=state.subnets[server_interface.subnet]):
            if ports is None or ports == []:
                #print("ports is None or empty")
                return obs

        server_address = server_interface.ip_address
        if server_address is None:
            #print("server address is NOne")
            return obs

        if self.ip_address == IPv4Address("127.0.0.1"):
            target_host = state.hosts[session.host]
        else:
            target_host = state.hosts[state.ip_addresses[self.ip_address]]

        ssh_proc = None
        port = None
        # should also check for a non-ssh process listening on port 22 - only extra info in obs will be that this
        # process exists on that port and IP
        for proc in target_host.processes:
            if proc.process_type == ProcessType.SSH:
                for conn in proc.connections:
                    if conn['local_port'] == self.port:
                        ssh_proc = proc
                        port = conn
                if ssh_proc is not None:
                    break

        if ssh_proc is None or (port["local_address"] != IPv4Address("0.0.0.0") and port["local_address"] != self.ip_address):
            #print("ssh_proc is None or port isn't listening on all or host interface")
            return obs

        # local port is not accessible from the originating host
        if not (conn['local_port'] in ports or 'all' in ports):
            #print(conn['local_port'])
            #print(ports)
            #print("all" not in ports)
            #print("port not accessible from originating host")
            return obs

        user_found = False
        user_user = None
        for u in target_host.users:
            if u.bruteforceable:
                user_found = True
                user_user = u

        if user_found:

            # multi-homed hosts may have more than 1 ip address
            hostid = state.ip_addresses[self.ip_address]
            origin_hostid = state.ip_addresses[server_address]


            # identify if there is already an existing session on the host
            host_sessions = state.get_sessions_by_host(self.agent, target_host)
            for sess in host_sessions:
                if sess.username == user_user:
                    # there isn't a new session (we create this later in the other cases)
                    obs=self.__reuse_session(hostid, origin_hostid, server_address, existing_session, server_session)
                    return obs

            obs.set_success(True)

            # adds process to the obs
            # do we need this temporary state change? this process is added to the obs when successful
            # removing complexity.  this temporary state change is not cleaned up in the event of failure
            #obs.add_process(hostid=hostid, local_address=self.ip_address, local_port=self.port, status="open",
            #                process_type="ssh", app_protocol='ssh')

            # add process to the target Simulated State
            # this adds the new sshd process upon successful ssh connection
            user_ssh = target_host.add_process(name="sshd", ppid=ssh_proc.pid, path=ssh_proc.path,
                                                                   user=user_user, process_type="ssh")

            remote_port = state.hosts[server_session.host].get_ephemeral_port()
            # we add the shell child connection-type process to the target Simulated State.
            user_shell = target_host.add_process(name="bash", ppid=user_ssh.pid, path="/bin", user=user_user, open_ports = {"local_port": self.port,
                "remote_address": server_address, "remote_port": remote_port, "local_address": self.ip_address} )
                    
            # add session to target Simulated State
            new_session = state.add_session(host=target_host.hostname, agent=self.agent, process=user_ssh.pid,
                                            user=user_user.username, session_type="msf_shell", parent=server_session.ident)

            remote_port_dict = {'local_port': remote_port,
                                "Application Protocol": "ssh",
                                "local_address": server_address,
                                "remote_address": self.ip_address,
                                "remote_port": self.port
                                }
            # add connection to the server Simulated State
            state.hosts[server_session.host].get_process(server_session.pid).connections.append(remote_port_dict)
            # not sure what this is doing
            #if session != server_session:
            #    remote_port = None

            # add server process to observation
            # adding connection-type process type to observation.  Not adding pid as this is not observed in the emulated case?
            obs.add_process(hostid=origin_hostid, local_address=server_address, remote_address=self.ip_address,
                            local_port=remote_port, remote_port=self.port)
            # add target process to observation
            obs.add_process(hostid=hostid, local_address=self.ip_address, remote_address=server_address,
                            local_port=self.port, remote_port=remote_port)
            # add target session to observation
            obs.add_session_info(hostid=hostid, username=user_user.username, session_id=new_session.ident, session_type="msf_shell", agent=self.agent)
            if target_host.os_type == OperatingSystemType.LINUX:
                obs.add_user_info(hostid=hostid, username=user_user.username, password=user_user.password, uid=user_user.uid)

                obs.add_system_info(hostid=hostid, hostname=target_host.hostname, architecture=target_host.architecture, os_kernel=target_host.kernel, os_type=target_host.os_type, os_distribution=target_host.distribution)
            else:
                obs.add_user_info(hostid=hostid, username=user_user.username, password=user_user.password)

            # disabled.  multi-homed host interfaces now discoverable by MeterpreterIPConfig action
            # for multi-homed hosts, also return the details of the other interfaces
            # this may need to be a separate action depending on what the emulated
            # case does
            #target_interface = target_host.get_interface(ip_address=self.ip_address)
            #for interface in target_host.interfaces:
            #    if interface.ip_address != lo and interface.ip_address != target_interface.ip_address:
            #      obs.add_interface_info(hostid=hostid,ip_address=interface.ip_address, subnet=interface.subnet)

        else:
            print("user not found")
        return obs

    def __reuse_session(self, hostid, origin_hostid, server_address, existing_session, server_session):
            # for reusing sessions, how do we get the origin server details? Should we just reuse the current server details
            # NOTE: in the future, we will need to match according to the same server details as well
            # add server process to observation
            # adding connection-type process type to observation.  not adding pid as this is not observed in the emulated case.
            obs.set_success(True)
            obs.add_process(hostid=origin_hostid, local_address=server_address, remote_address=self.ip_address,
                            local_port=server_session.local_port, remote_port=server_session.remote_port)
            # add target process to observation
            obs.add_process(hostid=hostid, local_address=self.ip_address, remote_address=server_address,
                            local_port=existing_session.local_port, remote_port=existing_session.remote_port)
            # add target session to observation
            # adding pid to session
            obs.add_session_info(hostid=hostid, username=user_user.username, session_id=existing_session.ident, session_type="msf_shell", agent=self.agent)
            if target_host.os_type == OperatingSystemType.LINUX:
                obs.add_user_info(hostid=hostid, username=user_user.username, password=user_user.password, uid=user_user.uid)

                obs.add_system_info(hostid=hostid, hostname=target_host.hostname, architecture=target_host.architecture, os_kernel=target_host.kernel, os_type=target_host.os_type, os_distribution=target_host.distribution)
            else:
                # we should also add system_info for windows (emulated case does it).  removed from emulated case for the moment.
                obs.add_user_info(hostid=hostid, username=user_user.username, password=user_user.password)

            # for multi-homed hosts, also return the details of the other interfaces
            # this may need to be a separate action depending on what the emulated
            # case does
            # no longer need to do this as we have separate action for this
            #target_interface = target_host.get_interface(ip_address=self.ip_address)
            #for interface in target_host.interfaces:
            #    if interface.ip_address != lo and interface.ip_address != target_interface.ip_address:
            #      obs.add_interface_info(hostid=hostid,ip_address=interface.ip_address, subnet=interface.subnet)

    def emu_execute(self, session_handler) -> Observation:
        obs = Observation()
        stop_on_success = True  # for the speed up during testing
        from CybORG.Emulator.Session import MSFSessionHandler
        if type(session_handler) is not MSFSessionHandler:
            obs.set_success(False)
            return obs
        output = session_handler.execute_module(mtype='auxiliary', mname='scanner/ssh/ssh_login',
                                         opts={'RHOSTS': str(self.ip_address), "USERPASS_FILE": '/usr/share/wordlists/top100_userpass_msf.txt', "STOP_ON_SUCCESS": stop_on_success})
        obs.add_raw_obs(output)
        obs.set_success(False)
        username = None  # cheat to allow us to know the username of the new session
        try:
            for line in output.split('\n'):
                # Example success line: "[+] 10.0.2.164:22 - Success: 'pi:raspberry' 'uid=1001(pi) gid=1001(pi) groups=1001(pi) Linux pretend-pi 4.15.0-1057-aws #59-Ubuntu SMP Wed Dec 4 10:02:00 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux '"
                # another example: [+] Success: 'pi:raspberry' 'uid=1001(pi) gid=1001(pi) groups=1001(pi) Linux ip-10-0-31-50 4.15.0-1057-aws #59-Ubuntu SMP Wed Dec 4 10:02:00 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux '
                # another example: [+] Success: 'pi:raspberry' 'Could not chdir to home directory /home/pi: No such file or directory uid=1001(pi) gid=1001(pi) groups=1001(pi) Could not chdir to home directory /home/pi: No such file or directory Linux ip-10-0-10-199 4.15.0-1057-aws #59-Ubuntu SMP Wed Dec 4 10:02:00 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux '
                if '[+]' in line:
                    # session_handler._log_debug(f"New positive result: {line}")
                    if ':' in line.split('Success: ')[0]:
                        ip_address, port = line.split('Success: ')[0].split(' ')[1].split(':')
                    else:
                        ip_address = self.ip_address
                        port = self.port
                    line = line.split('Success: ')[-1]
                    split = line.split(' ')
                    # print(list(enumerate(split)))
                    if 'Could not chdir to home directory' in line:
                        split = [split[0]] + split[13:16] + split[28:]
                    username, password = split[0].replace('\'', '').split(':')
                    if 'id: command not found' not in line:
                        # the following pattern is not returned in the Win64-OpenSSH implementation output in our environments
                        # implement better regex pattern detection
                        # only the uid was used in the original implementation.  Removed from this implementation
                        # uid = split[1].replace('\'', '').split('=')[1].split('(')[0]
                        # gid = split[2].replace('\'', '').split('=')[1].split('(')[0]
                        # group = split[3].replace('\'', '').split('=')[1].split('(')[1].split(')')[0]
                        # detect OS from pattern match
                        if "Linux" in line:
                          os = split[4]
                          hostname = split[5]
                          os_kv = split[6]
                          os_d = split[7].split('-')[1]
                          arch = split[15]
                          # simulator doesn't add system info for windows. should update simulator.
                          obs.add_system_info(hostid=str(self.ip_address), hostname=hostname, os_type=os, os_distribution=os_d, architecture=arch)
                        elif "Windows" in line:
                            # hardcode the single Windows OS version we are using for this environment
                            # Microsoft Windows Server 2008 R2 Standard 6.1.7601 Service Pack 1 Build 7601
                            # TODO: construct regex to dynamically determine this information
                            # os = (" ".join(split[1:6])).replace('\'','')
                            os = "windows"
                            os_d = "windows_2008_srv"
                            #os_kv = "6.1.7601"
                            arch = "x64"
                            hostname = None

                        obs.add_user_info(hostid=str(self.ip_address), username=username, password=password)
                        # this is duplicate of below
                        #obs.add_process(hostid=str(self.ip_address), local_port=port, local_address=ip_address, app_protocol='ssh', status='open', process_type="ssh")
                    else:
                        obs.add_user_info(hostid=str(self.ip_address), username=username, password=password)
                        #obs.add_process(hostid=str(self.ip_address), local_port=port, local_address=ip_address,
                        #                app_protocol='ssh', status='open', process_type="ssh")
                    # print(f'ip: {ip_address}')
                    # print(f'port: {port}')
                    # print(f'user: {username}')
                    # print(f'password: {password}')
                    # print(f'uid: {uid}')
                    # print(f'gid: {gid}')
                    # print(f'groups: {group}')
                    # print(f'OS Type: {os}')
                    # print(f'hostname: {hostname}')
                    # print(f'OS kernel version: {os_kv}')
                    # print(f'OS distro: {os_d}')
                    # print(f'arch: {arch}')
                    # print(f'time: {time}')
                if '[*]' in line:
                    #if "Command shell session" in line:
                    #print(line)
                    #print("SSH session" in line)
                    if "SSH session" in line:
                        obs.set_success(True)
                        split = line.split(' ')
                        # print(list(enumerate(split)))
                        session = int(split[3])
                        print(session)
                        local_address, local_port = split[7][:-1].split(':')
                        print(local_address, local_port)
                        if '-' in split[5]:
                            local_tunnel = split[5].replace('(', '').split(':')
                            origin, remote_address = local_tunnel[0].split('-')
                            # obs.add_process(hostid=str(origin), remote_address=remote_address, local_address=origin)
                            # obs.add_process(hostid=str(remote_address), local_address=remote_address, remote_address=origin)
                            remote_port = local_tunnel[1]
                        else:
                            remote_address, remote_port = split[5].replace('(', '').split(':')

                        #date = datetime.fromisoformat(split[10] + ' ' + split[11])
                        print("add session process")
                        obs.add_session_info(hostid=str(self.ip_address), username=username, session_id=session, agent=self.agent, session_type='msf shell')
                        obs.add_process(hostid=str(self.ip_address), local_port=local_port, remote_port=remote_port, local_address=local_address, remote_address=remote_address)
                        obs.add_process(hostid=str(remote_address), local_address=remote_address,
                                        local_port=remote_port, remote_port=local_port,
                                        remote_address=local_address)
                        # print(f'session: {session}')
                        # print(f'local_port: {local_port}')
                        # print(f'local_address: {local_address}')
                        # print(f'remote_port: {remote_port}')
                        # print(f'remote_address: {remote_address}')
                        # print(f'date: {date}')
        except Exception as ex:
            session_handler._log_debug(f'Error occured in parsing of output: {output}')
            raise ex

        session_handler._log_debug(output)
        return obs

    def __str__(self):
        return super(SSHLoginExploit, self).__str__() + f", Target: {self.ip_address}:{self.port}"
